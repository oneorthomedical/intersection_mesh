<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loaders - OBJ loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>

		<script type="module">

			import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.161.0/three.module.js';

			import { OBJLoader } from './build/OBJLoader.js';
            import { OrbitControls } from './build/OrbitControls.js';
            import CameraControls from './build/camera-controls.module.js';
			let container;

			let camera, scene, renderer,renderTarget,depthTarget1,depthTarget2,quad,postScene,postCamera,postMat;

			let mouseX = 0, mouseY = 0;
            let controls;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;
            const clock = new THREE.Clock();

			let object;
            let object2;
            let objectClone;

			init();
			animate();


			function init() {
                CameraControls.install( { THREE: THREE } );
				container = document.createElement( 'div' );
                document.body.appendChild(container);

                postScene = new THREE.Scene();
                postCamera = new THREE.OrthographicCamera(
                      -1, // left
                      1, // right
                      1, // top
                      -1, // bottom
                      -1, // near,
                      1 // far
                );
                const plane = new THREE.PlaneBufferGeometry(2, 2);
                postMat = postShaderClone();
               
                quad = new THREE.Mesh(plane,postMat);
                quad.position.z = -1;
                postScene.add(quad);
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set(0,300,0);
                camera.up.set(0,0,1);

            
				// scene

				scene = new THREE.Scene();

				const ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
				scene.add( ambientLight );

				const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				camera.add( pointLight );
				scene.add( camera );
                window.THREE = THREE;
                 window.scene = scene;

				// manager

				function loadModel() {

					object.traverse( function ( child ) {
                         objectClone = child.clone();
                         child.material = new THREE.MeshPhongMaterial({
                             depthWrite : false,
                             side : THREE.FrontSide,
                             transparent : true,
                             opacity : 0.6
                         })
					});
                    object.add(objectClone);
                    objectClone.material = createShaderClone();
                    object2.traverse( function ( child ) {
                        child.material = new THREE.MeshStandardMaterial({
                        color: 0x048b9a,
                        transparent: false
                    });
                    });
                    object2.position.set(117.46, -40.67, 14.66);
                    object2.scale.set(1.2, 1., 1.);
                    object2.rotation.set(0.2,0.05,-0.38);
                    object2.renderOrder = 1;
					scene.add( object, object2 );

				}

				const manager = new THREE.LoadingManager( loadModel );

				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );

				};

				// model

				function onProgress( xhr ) {

					if ( xhr.lengthComputable ) {

						const percentComplete = xhr.loaded / xhr.total * 100;
						console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );

					}

				}

				function onError() {}

				const loader = new OBJLoader( manager );
				loader.load( './models/femur.obj', function ( obj ) {

					object = obj;

				}, onProgress, onError );


                const loader2 = new OBJLoader( manager );
				loader2.load( './models/5.obj', function ( obj ) {
                
                        object2 = obj;

				}, onProgress, onError );

				//

				renderer = new THREE.WebGLRenderer({
                    alpha : true
                });
                renderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth / 1,
                window.innerHeight / 1
                );
                depthTarget1 = new THREE.WebGLRenderTarget(
                window.innerWidth / 1,
                window.innerHeight / 1
                );
                depthTarget1.depthBuffer = true;
                depthTarget1.depthTexture = new THREE.DepthTexture();
                depthTarget2 = new THREE.WebGLRenderTarget(
                window.innerWidth / 1,
                window.innerHeight / 1
                );
                depthTarget2.depthBuffer = true;
                depthTarget2.depthTexture = new THREE.DepthTexture();
                postMat.uniforms.p.value = renderTarget.texture;
                postMat.uniforms.p1.value = depthTarget1.texture;
                postMat.uniforms.p2.value = depthTarget2.depthTexture;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
                controls = new CameraControls( camera, renderer.domElement );
				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {
                const delta = clock.getDelta();
                const hasControlsUpdated = controls.update(delta);
                renderer.setRenderTarget(depthTarget1);
                if (object) {
                   // object.visible = false;
                    }
                renderer.render(scene, camera);
                if (object) {
                    //object.visible = true;
                    }
                renderer.setRenderTarget(null); 

                 renderer.setRenderTarget(depthTarget2);
                if (object2) {
                    //object2.visible = false;
                   // object2.material.depthWrite = true;
                   // object2.material.transparent = false;
                    }
                renderer.render(scene, camera);
                if (object2) {
                   // object2.visible = true;
                    }
                renderer.setRenderTarget(null); 

                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);
                renderer.setRenderTarget(null);
                renderer.render(postScene, postCamera);

            }
            function postShaderClone() {
               return new THREE.ShaderMaterial(
                {
                    uniforms: {
                    // @ts-ignore
                        p: { value: null },
                        p1: { value: null },
                        p2: { value: null},
                    // @ts-ignore
                    glowColor: {type: 'c', value: new THREE.Color(0xFFFFFF)},
                    },
                    vertexShader: `
                     
                       varying vec2 vUv;
                        
                        void main()
                        {
                      vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                         
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D p;
                        uniform sampler2D p1;
                        uniform sampler2D p2;
                        varying vec2 vUv;
                        void main()
                        {
                            vec4 col = vec4(texture2D(p,vUv));
float a = 0.0;
if(col.r>0.35){
a = 1.0;
}

                           gl_FragColor =vec4(col.a)*vec4(0.,1.,0.,0.)*a+col;
//gl_FragColor = vec4(a);
//gl_FragColor = vec4(col.rgb*0.5,1.);
                        }
                        `
                  
                });
            }

            function createShaderClone() {
                return new THREE.ShaderMaterial(
                {
                    uniforms: {
                    // @ts-ignore
                    p: {type: 'f', value: 0.44},
                    // @ts-ignore
                    glowColor: {type: 'c', value: new THREE.Color(0xFFFFFF)},
                    },
                    vertexShader: `
                        uniform float p;
                        varying float intensity;
                        #include <clipping_planes_pars_vertex>
                        void main()
                        {
                            #include <begin_vertex>
                            vec3 vNormal = normalize( normalMatrix * normal );
                            intensity = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), p);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                            #include <project_vertex>
                            #include <clipping_planes_vertex>
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 glowColor;
                        varying float intensity;
                        #include <clipping_planes_pars_fragment>
                        void main()
                        {
                        #include <clipping_planes_fragment>
                            vec3 glow = glowColor * intensity;
                            gl_FragColor = vec4( glow, 1 );
                        }
                        `,
                    side: THREE.BackSide,
                    blending: THREE.SubtractiveBlending,
                    transparent: true,
                    depthWrite: false,
                });
             }

		</script>

	</body>
</html>