<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loaders - OBJ loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>

		<script type="module">

			import * as THREE from './build/three.module.js';

			import { OBJLoader } from './build/OBJLoader.js';
            import { OrbitControls } from './build/OrbitControls.js';
            import CameraControls from './build/camera-controls.module.js';
			let container;

			let camera, scene, renderer;

			let mouseX = 0, mouseY = 0;
            let controls;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;
            const clock = new THREE.Clock();

			let object;
            let object2;
            let objectClone;

			init();
			animate();


			function init() {
                CameraControls.install( { THREE: THREE } );
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set(0,300,0);
                camera.up.set(0,0,1);

            
				// scene

				scene = new THREE.Scene();

				const ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
				scene.add( ambientLight );

				const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				camera.add( pointLight );
				scene.add( camera );
                window.THREE = THREE;
                 window.scene = scene;

				// manager

				function loadModel() {

					object.traverse( function ( child ) {
                         objectClone = child.clone();
                         child.material = new THREE.MeshPhongMaterial({
                             depthWrite : false,
                             side : THREE.FrontSide,
                             transparent : true,
                             opacity : 0.6
                         })
					});
                    object.add(objectClone);
                    objectClone.material = createShaderClone();
                    object2.traverse( function ( child ) {
                        child.material = new THREE.MeshStandardMaterial({
                        color: 0x048b9a,
                        transparent: false
                    });
                    });
                    object2.position.set(117.46,-40.67,14.66);
                    object2.rotation.set(0.2,0.05,-0.38);
                    object2.renderOrder = 1;
					scene.add( object, object2 );

				}

				const manager = new THREE.LoadingManager( loadModel );

				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );

				};

				// model

				function onProgress( xhr ) {

					if ( xhr.lengthComputable ) {

						const percentComplete = xhr.loaded / xhr.total * 100;
						console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );

					}

				}

				function onError() {}

				const loader = new OBJLoader( manager );
				loader.load( './models/femur.obj', function ( obj ) {

					object = obj;

				}, onProgress, onError );


                const loader2 = new OBJLoader( manager );
				loader2.load( './models/5.obj', function ( obj ) {
                
                        object2 = obj;

				}, onProgress, onError );

				//

				renderer = new THREE.WebGLRenderer({
                    alpha : true
                });
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
                controls = new CameraControls( camera, renderer.domElement );
				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {
                const delta = clock.getDelta();
                const hasControlsUpdated = controls.update( delta );
				renderer.render( scene, camera );

			}

            function createShaderClone() {
                return new THREE.ShaderMaterial(
                {
                    uniforms: {
                    // @ts-ignore
                    p: {type: 'f', value: 0.44},
                    // @ts-ignore
                    glowColor: {type: 'c', value: new THREE.Color(0xFFFFFF)},
                    },
                    vertexShader: `
                        uniform float p;
                        varying float intensity;
                        #include <clipping_planes_pars_vertex>
                        void main()
                        {
                            #include <begin_vertex>
                            vec3 vNormal = normalize( normalMatrix * normal );
                            intensity = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), p);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                            #include <project_vertex>
                            #include <clipping_planes_vertex>
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 glowColor;
                        varying float intensity;
                        #include <clipping_planes_pars_fragment>
                        void main()
                        {
                        #include <clipping_planes_fragment>
                            vec3 glow = glowColor * intensity;
                            gl_FragColor = vec4( glow, 1 );
                        }
                        `,
                    side: THREE.BackSide,
                    blending: THREE.SubtractiveBlending,
                    transparent: true,
                    depthWrite: false,
                });
             }

		</script>

	</body>
</html>